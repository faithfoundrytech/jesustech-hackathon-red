---
description: 
globs: *.tsx
alwaysApply: false
---
âš›ï¸ React Optimization Instructions
ðŸŽ¯ Goal:
Optimize component performance by preventing unnecessary re-renders using React.memo, useCallback, and useMemo.

âœ… Use React.memo:
Wrap functional components that:

Receive props that rarely change

Are pure (same input â†’ same output)

Are child components of frequently re-rendering parents

js
Copy
Edit
const MyComponent = React.memo((props) => { ... });
ðŸ” Use useCallback:
Wrap functions passed as props to memoized components to avoid prop changes on every render.

js
Copy
Edit
const handleClick = useCallback(() => {
  doSomething();
}, [doSomething]); // keep dependencies minimal
Use it only if:

Youâ€™re passing the function to a React.memo child

Or itâ€™s used in useEffect/useMemo dependencies

ðŸ’¾ Use useMemo:
Wrap objects or arrays passed as props or used in heavy computations.

js
Copy
Edit
const config = useMemo(() => ({ darkMode: true }), []);
Use when:

Youâ€™re passing objects/arrays to memoized children

Or performing expensive calculations

ðŸ“‰ Keep Dependency Arrays Minimal:
In useEffect, useCallback, and useMemo, only include values that the function depends on. Avoid unnecessary dependencies.

Bad:

js
Copy
Edit
useCallback(() => doSomething(), [someState, unusedVar]);
Good:

js
Copy
Edit
useCallback(() => doSomething(), []);
ðŸ›‘ Avoid:
Re-creating functions/objects inside render unless memoized

Overusing useCallback or useMemo without need

Triggering state changes inside useEffect without condition

